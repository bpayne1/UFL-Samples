const MY_WEB_API_URL = "https://XXXXXXXXXXX@salesprovcloud1.cloudapp.net/piwebapi/";

const MY_AF_ATTRIBUTE_PATH_LATITUDE  = @"\\piaf01\ExperimentalSensors\Imps\ElectricImp01|Latitude";
const MY_AF_ATTRIBUTE_PATH_LONGITUDE = @"\\piaf01\ExperimentalSensors\Imps\ElectricImp01|Longitude";

// Standard headers used with all requests
local MY_HEADERS = { "Content-Type": "application/json" };

// If this is turned on, logging is enabled
const LOGGING_ENABLED = 1;

// Helper functions for sending to the PI Web API ------------------------------

local MyAFAttributeAndWebIdTable = {};

// Look up all of the Web ID's for the attributes that will be used
device.on("GetWebIDsForAFAttributes", function (MyAFAttributeArray) {
   server.log("\nNow get Web IDs...");
   
   // For each AF attribute, add an item to the array containing the web ID
    for (local i = 0; i < MyAFAttributeArray.len(); i++){
        
        // Get the AF attribute path, then use it to get the Web ID
        local MyAFattributePath = MyAFAttributeArray[i];
        local MyWebID = GetWebIdForAFAttribute(MY_WEB_API_URL, MyAFattributePath);
        
        // Store the Web ID in a table, indexed by the AF path
        MyAFAttributeAndWebIdTable[MyAFattributePath] <- MyWebID;
        server.log("New table entry: " + MyAFattributePath + "\n" + MyAFAttributeAndWebIdTable[MyAFattributePath] + "\n\n")    
        
    }
});


// Catch bulk data from the Imp and send it along
device.on("sendAFPathAndValueToCloudInBulk", function (MyAFPathAndValueBulkArray) {
    // Loop through the bulk array and handle each individual item
    for (local i = 0; i < MyAFPathAndValueBulkArray.len(); i++){
        sendToPIWebAPI(MY_WEB_API_URL, MyAFPathAndValueBulkArray[i])
    }
    
    // When done, get the location
    getLocation();
});

// Send the PI Web API request
function sendToPIWebAPI(MyPIWebAPIURL, MyAFPathAndValueArray) {
    

    // Extract the value and the AF attribute path from the message
    local MyAFattributePath = MyAFPathAndValueArray[0];
    local MyValue = MyAFPathAndValueArray[1];
    
    // Get the PI Web API Web ID for this AF attribute
    if (LOGGING_ENABLED) server.log("\n");
    //local MyWebID = GetWebIdForAFAttribute(MyPIWebAPIURL, MyAFattributePath);
    local MyWebID = MyAFAttributeAndWebIdTable[MyAFattributePath];
    if (LOGGING_ENABLED) server.log("Web ID and AF Path: " + MyWebID + "\n" + MyAFattributePath);
    
    // If the Web ID get was successful, then continue!
    if (MyWebID != "") {
        // Get the date
        local d = date(); 
        local MyTimestamp_formatted = format("%04d-%02d-%02dT%02d:%02d:%02d", d.year, d.month+1, d.day, d.hour, d.min, d.sec) + "Z";
        
        // Format the string data as JSON; it will arrive in format MyData = {"Value": MyValue, "Timestamp": MyTimestamp};
        local MyData = {"Value": MyValue, "Timestamp": MyTimestamp_formatted};
        local MyDataAsJSON = http.jsonencode(MyData);
        if (LOGGING_ENABLED) server.log("Data to be written: " + MyDataAsJSON);
        
        // Send the second request to post the data
        local MyURL2 = MyPIWebAPIURL + "streams/" + MyWebID + "/value";
         if (LOGGING_ENABLED) server.log("Now posting to URL: " + MyURL2);
    
        // Send the second query to update the value
        local MyRequest2 = http.post(MyURL2, MY_HEADERS, MyDataAsJSON);
        MyRequest2.sendasync(MyAsyncResponseHandler);
    } else {
        if (LOGGING_ENABLED) server.log("Web ID was null!");
    }
}

// Return a string PI Web API WebID given a particular AF Path
function GetWebIdForAFAttribute(MyPIWebAPIURL, MyAFattributePath) {
    
    // Define the URL for getting the Web ID
    local MyURL1 = MyPIWebAPIURL + "attributes?path=" + MyAFattributePath;

    // Build the request and send it
    local MyRequest1 = http.get(MyURL1, MY_HEADERS);
    if (LOGGING_ENABLED) server.log("URL for requesting Web ID: " + MyURL1);
    local MyResponse1 = MyRequest1.sendsync();
    
    // Decide the response
    local MyResponse1Decoded = null;
    try {
        MyResponse1Decoded = http.jsondecode(MyResponse1.body);
    } catch (error)
    {
        server.log("Error when trying to get Web ID: " + error)
    }
    
    // If we indeed got the web ID, proceed with the post
    local MyWebID = "";
    if (MyResponse1Decoded != null) {
        // Get the Web ID and log it
        MyWebID = MyResponse1Decoded.WebId;
        if (LOGGING_ENABLED) server.log("Result of getting Web ID of target stream: " + MyWebID);
    }
    
    // Return the web ID; if there was a success, it will not be equal to ""
    return MyWebID;
}

function WriteDataUsingPIWebAPI(MyPIWebAPIURL, MyAFPathAndValueBulkArray) {
    
}

// Handles responses from the PI Web API POST
function MyAsyncResponseHandler(MyResponse) {
    
    // Log the response
    if (LOGGING_ENABLED) {
        if (MyResponse.body != "") {
            server.log("Async response to write attempt: errors on data write: " + MyResponse.body);
        }
        else {
            server.log("Async response to write attempt: no error detected when writing to PI System!");
        }
    }
}

// -----------------------------------------------------------------------------------------------------

// Courtesy of Google; see https://github.com/electricimp/reference/tree/master/webservices/google

// -----------------------------------------------------------------------------
// WifiTimezone class
//
// Requests the imp to scan for wifi networks, sends that data to Google Maps to 
// geolocate the imp, sends that data to Google Maps to collect timezone data
//
class WifiTimezone {
    
    _scan_keyword = null;
    _wifis = null;
    _location = null;
    
    // -------------------------------------------------------------------------
    constructor(scan_keyword = "scanForWifiNetworks") {
        
        _scan_keyword = scan_keyword;
        _wifis = [];
        _location = {};
        
    }
    
    // -------------------------------------------------------------------------
    // Requests the imp to scan the wifi networks it can see and return 
    // them all in a callback
    // 
    function getWifis(callback, timeout = 10) {

        // Send the command to the device to run the scan
        device.send(_scan_keyword, _scan_keyword)
        local timer;
        
        // Handle the reply
        device.on(_scan_keyword, function(wifis) {
            
            if (timer) imp.cancelwakeup(timer); timer = null;
            
            _wifis = wifis;
            callback(null, _wifis);
            device.on(_scan_keyword, function(d) {});
            
        }.bindenv(this));

        // Handle a timeout
        timer = imp.wakeup(timeout, function() {
            timer = null;

            callback("wifis timeout", null);
            device.on(_scan_keyword, function(d) {});
            
        }.bindenv(this))
        
    }
    
    // -------------------------------------------------------------------------
    // Sends the visible Wifi networks to Google to geolocate
    //
    function getLocation(callback, timeout = 60) {
        if (_wifis.len() == 0) throw "You must scan for wifi networks first";

        // Build the URL and POST data
        local timer;
        local url = "https://maps.googleapis.com/maps/api/browserlocation/json?browser=electric-imp&sensor=false";
        local headers = {};
        foreach (newwifi in _wifis) {
           
            local bssid = format("%s:%s:%s:%s:%s:%s", newwifi.bssid.slice(0,2), 
                                                      newwifi.bssid.slice(2,4), 
                                                      newwifi.bssid.slice(4,6), 
                                                      newwifi.bssid.slice(6,8), 
                                                      newwifi.bssid.slice(8,10), 
                                                      newwifi.bssid.slice(10,12));
            url += format("&wifi=mac:%s|ss:%d", bssid, newwifi.rssi);
            
       }
       
       // POST it to Google
       local req = http.get(url, headers);
       req.sendasync(function(res) {
    
            if (timer) imp.cancelwakeup(timer); timer = null;
           
            local err = null;
            if (res.statuscode == 200) {
                local json = http.jsondecode(res.body);
                if (!("status" in json)) {
                    err = format("Unexpected response from Google Location: %s", res.body);
                } else if (json.status == "OK") {
                    return callback(null, _location = json.location)
                } else {
                    err = format("Received status %s from Google Location", json.status);
                }
            } else {
                err = format("Received error response %d from Google Location", res.statuscode);
            }
            callback(err, null);
           
        }.bindenv(this));

       
        // Handle a timeout
        timer = imp.wakeup(timeout, function() {
            timer = null;

            req.cancel();
            callback("location timeout", null);
            
        }.bindenv(this))
       
    }
    
    // -------------------------------------------------------------------------
    // status	    Status of the API query. Either OK or FAIL.
    // timeZoneId	The name of the time zone. Refer to time zone list.
    // timeZoneName The long description of the time zone
    // gmtOffsetStr GMT Offset String such as GMT-7
    // rawOffset    The time zone's offset without DST changes
    // dstOffset    The DST offset to be added to the rawOffset to get the current gmtOffset
    // gmtOffset	The time offset in seconds based on UTC time.
    // time         Current local time in Unix timestamp.   
    // date         Squirrel date() object
    // dateStr      Date string formatted as YYYY-MM-DD HH-MM-SS
    //
    function getTZdata(callback, timeout = 60) {
        if (_location.len() != 2) throw "You must scan for wifi and get the location data first";

        // POST the location data to timezonedb
        local timer;
        local url = "https://maps.googleapis.com/maps/api/timezone/json?location=" + _location.lat + "," + _location.lng+"&timestamp="+time()+"&sensor=false";
        local headers = {};
        local req = http.get(url, headers);
        req.sendasync(function(res) {

            if (timer) imp.cancelwakeup(timer); timer = null;

            local err = null;
            local json = http.jsondecode(res.body);
            if (!("status" in json)) {
                err = format("Unexpected response from TimezoneDB: %s", res.body);
            } else if (json.status == "OK") {
                local t = time() + json.rawOffset + json.dstOffset;
                local d = date(t);
                json.time <- t;
                json.date <- d;
                json.dateStr <- format("%04d-%02d-%02d %02d:%02d:%02d", d.year, d.month+1, d.day, d.hour, d.min, d.sec)
                json.gmtOffset <- json.rawOffset + json.dstOffset;
                json.gmtOffsetStr <- format("GMT%s%d", json.gmtOffset < 0 ? "-" : "+", math.abs(json.gmtOffset / 3600));
                return callback(null, json);
            } else {
                err = format("Received status %s from TimezoneDB", json.status);
            }
            callback(err, null);
            
        }.bindenv(this));

       
        // Handle a timeout
        timer = imp.wakeup(timeout, function() {
            timer = null;

            req.cancel();
            callback("tzdata timeout", null);
            
        }.bindenv(this))
       
        
    }
    
    
    // -------------------------------------------------------------------------
    // Calls getWifis(), getLocation() and getTZdata() and returns them all to the callback
    // callback = function(err, wifis, location, tzdata);
    //
    function get(callback) {
        getWifis(function(err, wifis) {
            if (err != null) return callback(err, wifis, null, null);
            getLocation(function(err, location) {
                if (err != null) return callback(err, wifis, location, null);
                getTZdata(function(err, tzdata) {
                    callback(err, wifis, location, tzdata);
                }.bindenv(this)); // getTZdata
            }.bindenv(this)); // getLocation
        }.bindenv(this)); // getWifis
    }
    

}



// ------------------------[ Example code ]------------------------

wtz <- WifiTimezone();
function getLocation() {
    wtz.get(function(err, wifis, location, tzdata) {
        if (err == null) {
            //server.log(format("%s %s", tzdata.dateStr, tzdata.gmtOffsetStr));
            server.log("\n --------------------- Position found! " + location.lat + "," + location.lng);
            
            // Now that you have loated the IMP, store it's information in the PI System
            sendToPIWebAPI(MY_WEB_API_URL, [MY_AF_ATTRIBUTE_PATH_LATITUDE, location.lat]);
            sendToPIWebAPI(MY_WEB_API_URL, [MY_AF_ATTRIBUTE_PATH_LONGITUDE, location.lng]);
        } else {
            server.error(err);
        }
    }.bindenv(this));
}

device.onconnect(function() { getLocation() });
